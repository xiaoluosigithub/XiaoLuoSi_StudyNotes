![](https://i-blog.csdnimg.cn/blog_migrate/2c7a6e57320cd4d6bf04bae0664f568d.jpeg)

本文将为大家介绍经典神经网络的开山力作——AlexNet（ImageNet Classification with Deep Convolutional Neural Networks）。文章包含论文原文翻译＋精读＋个人学习总结。  
研一萌新，第一次发文，不足之处多多包涵啦~

论文原文：[http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf][http_papers.nips.cc_paper_4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf]

## 目录 

[目录][Link 1]

[Abstract-摘要][Abstract-]

[1.Introduce—介绍][1.Introduce]

[2.The Dataset-数据集][2.The Dataset-]

[3.The Architecture—网络结构][3.The Architecture]

[3.1ReLU Nonlinearity—非线性激活函数ReLU][3.1ReLU Nonlinearity_ReLU]

[3.2Training on Multiple GPUs—用多个GPU训练][3.2Training on Multiple GPUs_GPU]

[3.3Local Response Normalization—局部归一化][3.3Local Response Normalization]

[3.4Overlapping Pooling—重叠池化][3.4Overlapping Pooling]

[3.5Overall Architecture—整体网络架构][3.5Overall Architecture]

[4.Reducing Overfitting—减少过拟合][4.Reducing Overfitting]

[4.1Data Augmentation—数据增强][4.1Data Augmentation]

[4.2Dropout—随机失活法][4.2Dropout]

[5.Details of learning—学习的细节][5.Details of learning]

[5.1SGD随机梯度下降法][5.1SGD]

[5.2初始化参数][5.2]

[5.3学习速率][5.3]

[6.Results—实验结果][6.Results]

[6.1Qualitative Evaluations—定性评估][6.1Qualitative Evaluations]

[7.Discussion—讨论][7.Discussion]

[论文十问][Link 2]

## Abstract-摘要 

### 翻译 

我们训练了一个庞大的深层卷积神经网络，将ImageNet LSVRC-2010比赛中的120万张高分辨率图像分为1000个不同的类别。在测试数据上，我们取得了37.5％和17.0％的前1和前5的错误率，这比以前的先进水平要好得多。具有6000万个参数和650,000个神经元的神经网络由五个卷积层组成，其中一些随后是最大池化层，三个全连接层以及最后的1000个softmax输出。为了加快训练速度，我们使用非饱和神经元和能高效进行卷积运算的GPU实现。为了减少全连接层中的过拟合，我们采用了最近开发的称为“dropout”的正则化方法，该方法证明是非常有效的。我们还在ILSVRC-2012比赛中使用了这种模式的一个变种，取得了15.3％的前五名测试失误率，而第二名的成绩是26.2％。

###    精读 

#### 主要内容 

（1）表示了用了一个深度卷积神经网络来进行图片分类，取得了一个非常好的效果。

（2）深度卷积网络由60million个参数，65w个神经元，以及五个卷积层和三个全连接层，一个1000路的softmax层组成。

（3）为了加快训练，用到了非饱和激活函数ReLU和卷积运算的GPU加速实现。

（4）用了Dropout这个随机失活方法来减少完全联通层的过拟。

> 相关问题一：过拟合和欠拟合
> 
> ● 神经网络的过拟合和欠拟合介绍：
> 
> 过拟合概念：过拟合现象一般都是因为学习的过于精确，就好比让机器学习人脸，取了100个人的脸训练，但是由于你学习的过精确，导致除了这个样本100人外其他的人脸神经网络都认为不是人脸，实际我们只需要学习人脸的基本特征而不是详细到人的皮肤细腻眼睛大小等过于细致的特征，这样可以保证机器还是能识别别的图片中的人脸的。
> 
> 过拟合的表现：模型在训练集上误差很小，在测试集上误差很大。 过拟合主要由两个方面决定：一是数据集，二是模型
> 
> 欠拟合概念：欠拟合是指模型不能在训练集上获得足够低的误差。而过拟合是指训练误差和测试误差之间的差距太大。
> 
> ● 如何判断深度神经网络是否过拟合：
> 
> 原则上RSquare值越高（越接近1），拟合性越好，自变量对因变量的解释越充分。但最重要的是看sig值，小于0.05，达到显著水平才有意义。 可以看回你spss的结果，对应regression的sig值如果是小于0.05的，就可以了。
> 
> ● 如何减少过拟合：
> 
> 减少过拟合需要具体情况具体分析。 一般由以下几种方法：
> 
> 模型角度 :1. 限制模型的复杂度（根据训练集的分布，选择复杂度合适的模型）。 2. L2正则限制特征权重，防止某些特征对结果影响太大。 3. L1正则产生稀疏权重，限制模型的复杂度。 4. 参数共享。 5. bagging 。6. 提前终止。 7. dropout 。8. BN
> 
> 数据角度：得到质量更高，数据量的数据。如数据增强。

> 相关问题二：Top-5错误率和Top-1错误率
> 
> Top-5错误率：一个图片经过网络，得到预测类别的概率，如果概率前五（top-5）中包含正确答案，即认为正确。top-5错误率就是Top-5 = （正确标记 不在 模型输出的前5个最佳标记中的样本数）/ 总样本数。
> 
> Top-1错误率：如果概率最大的是正确答案，才认为正确。Top-1 = （正确标记 不是 模型输出的最佳标记的样本数）/ 总样本数。

## 1. Introduction—前言 

### 翻译 

当前目标识别的方法基本都使用了机器学习的方法。为了提高这些方法的性能，我们可以收集更大的数据集，学习得到更加强大的模型，然后使用更好的方法防止过拟合。直到现在，相比于成千上百的图像，带标签的图像数据集相对较小（如NORB\[16\]，Caltech-101/256\[8,9\]，以及CIFAR-10/100\[12\]）。这种规模的数据集能使得简单的识别任务得到很好地解决，特别是如果他们进行带标签的转换来增广数据集。例如，当前MINIST数字识别任务最小的错误率（<0.3% ）已经接近人类水平\[4\]。但是现实世界中的目标呈现出相当大的变化性，因此学习去识别它们就必须要使用更大的训练数据集。事实上，人们也已广泛地认识到小图像数据集的缺点（如Pinto等\[21\]），但直到最近，收集包含数百万图像的带标签数据集才成为可能。新的更大的数据集包括由数十万张全分割图像的LabelMe\[23\]和包含超过22000类的1500万张带标签高分辨率图像ImageNet\[6\]组成。

为了从数以百万计的图像中学习出数千种的目标，我们需要一个具有很强学习能力的模型。然而，目标识别任务的巨大复杂性意味着，即使在ImageNet这样大的数据集也不能完成任务，因此我们的模型也要有许多先验知识来弥补所有我们没有的数据。卷积神经网络（CNNs）就形成了一种这样类别的模型\[16,11,13,18,15,22,26\]。可以通过改变网络的深度和广度控制CNN的学习能力，并且它们都能对图像的本质做出强大而又正确的判别（即统计的稳定性和像素位置的依赖性）。因此，相比于相似大小的标准前馈神经网络，CNNs的连接和参数更少，因此更易训练，尽管它们理论上的最优性能可能略差点。尽管CNNs具有一些新颖的特性，和更有效率的局部结构，但大规模地应用于高分辨率图像消耗资源仍然过多。幸运的是，如今GPU以及高度优化的二维卷积计算，已经足够强大地去帮助大规模CNNs的训练，并且最新的数据集如ImageNet包含足够多的带标签样本，能够训练出不会严重过拟合的模型。

本文具体贡献如下：基于ILSVRC-2010和ILSVRC-2012比赛中用到的ImageNet的子集本文训练出了至今为止一个最大的卷积神经网络\[2\]并且得到了迄今基于这些数据集最好的结果。本文实现了一种高度优化的二维卷积的GPU运算以及卷积神经网络训练中所有其他运算，这些都已公开提供；本文网络中包含了大量的不常见和新的特征来提升网络性能，减少训练时间，详见第三节；即使有120万带标签的训练样本，网络的大小使得过拟合仍成为一个严重的问题，因此本文使用了许多有效的防止过拟合的技术，详见第四节；本文最终的网络包含五层卷积层和三层全连接层，而这个深度似乎很重要：我们发现移除任何一层卷积层（每一层包含的参数个数不超过整个模型参数个数的1%）都会导致较差的结果。

最后，网络的大小主要受限于GPU的内存大小和我们愿意忍受的训练时间长度。本文的网络在两个GTX 580 3GB GPU上训练了五到六天。本文所有的实验表明，如果有更快的GPU、更大的数据集，结果可以更好。

### 精读 

#### 主要内容： 

（1）引出ImageNet这个数据集，介绍它很大很好。

（2）对于ImageNet可以采用CNN来作为本文的模型。

（3）介绍了本篇论文主要贡献。

> 相关问题一：Labelme和ImageNet：
> 
>  *  前者由数十万张完全分割的图像组成。
>  *  后者由超过22,000个类别的超过1500万张高分辨率标记图像组成。

#### 本文主要贡献： 

（1）基于ILSVRC-2010和ILSVRC-2012比赛中用到的ImageNet的子集，本文训练出了至今为止一个最大的卷积神经网络并且得到了迄今基于这些数据集最好的结果。

（2）本文实现了一种高度优化的二维卷积的GPU运算以及卷积神经网络训练中所有其他运算，这些都已公开提供。

（3）本文网络中包含了大量的少见和新的特征来提升网络性能，减少训练时间。

（4）本文使用了许多有效的防止过拟合的技术。

（5）本文最终的网络包含五层卷积层和三层全连接层，而这个深度似乎很重要：我们发现移除任何一层卷积层（每一层包含的参数个数不超过整个模型参数个数的1%）都会导致较差的结果。

## 2.The Dataset-数据集 

### 翻译 

ImageNet数据集包含有大概22000种类别共150多万带标签的高分辨率图像。这些图像是从网络上收集得来，由亚马逊的Mechanical Turkey的众包工具进行人工标记。从2010年开始，作为Pascal视觉目标挑战的一部分，ImageNet大规模视觉识别挑战（ImageNet Large-Scale Visual Recognition Challenge  
，ILSVRC）比赛每年都会举行。ILSVRC采用ImageNet的子集，共包含一千个类别，每个类别包含大约1000幅图像。总的来说，大约有120万张训练图像，5万张验证图像以及15万张测试图像。

ILSVRC-2010是ILSVRC唯一一个测试集标签公开的版本，因此这个版本就是本文大部分实验采用的数据集。由于我们也以我们的模型参加了ILSVRC-2012的比赛，在第6节本文也会列出在这个数据集上的结果，该测试集标签不可获取。ImageNet通常使用两种错误率：top-1和top-5，其中top-5错误率是指正确标签不在模型认为最有可能的前五个标签中的测试图像的百分数。

ImageNet包含不同分辨率的图像，但是本文的模型要求固定的输入维度。因此，本文将这些图像下采样为256x256 。给定一幅矩形图像，本文采用的方法是首先重新调整图像使得短边长度为256，然后裁剪出中央256x256 的区域。除了将图像减去训练集的均值图像(训练集和测试集都减去训练集的均值图像)，本文不做任何其他图像预处理。因此本文直接在每个像素的原始RGB值上进行训练。

### 精读 

#### 主要内容： 

（1）介绍了所使用到的ImageNet数据集

（2）介绍了本文所采用的图像处理的方法

（3）指明没有以任何方式做预处理比如抽取特征、抽取SIFT特征等等，直接将原始图片输入到神经网络模型，就能实现想要的功能。

#### ImageNet简介： 

ImageNet是一种数据集，而不是神经网络模型。斯坦福大学教授李飞飞为了解决机器学习中过拟合和泛化的问题而牵头构建的数据集。该数据集从2007年开始手机建立，直到2009年作为论文的形式在CVPR 2009上面发布。直到目前，该数据集仍然是深度学习领域中图像分类、检测、定位的最常用数据集之一。

![](https://i-blog.csdnimg.cn/blog_migrate/1506885cc34bc4b4cb95b0417b8b09e9.png)

#### 图像处理方法： 

（1）ImageNet这个数据集不像其他数据集一样，它没有对数据进行裁剪。所以我们要先对数据集进行裁剪，裁剪为：256\*256的尺寸大小。

（2）具体裁剪方法：先对原始图片进行缩放，将短边变成256的大小，另一个长边在这一步操作中也会根据长宽比进行调整，然后第二步从图片中心对长边进行两侧的裁剪，得到256\*256的尺寸大小。

## 3.The Architecture—网络结构 

图2概括了我们所提出网络的结构。它包含八个学习层——五个卷积层和三个全连接层。下面，我们将描述一些所提出网络[框架][Link 3]中新颖或不寻常的地方。 3.1-3.4节按照重要顺序排序。

###  3.1ReLU Nonlinearity—非线性激活函数ReLU 

### 翻译 

通常使用一个关于输入的函数模拟神经元的输出,，这种标准函数是或者。在梯度下降训练时间上，这些饱和的非线性函数比不饱和非线性函数更慢。根据Nair和Hinton\[20\]，本文将具有这种非线性特征的神经元称为修正线性单元（ReLUs: Rectified Linear Units）。使用ReLUs的深度卷积神经网络训练速度比同样情况下使用单元的速度快好几倍。图1表示使用特定的四层卷积网络在数据集CIFAR-10上达到25%错误率所需的迭代次数。这个图表明如果使用传统的饱和神经元模型我们不可能利用这么大规模的神经网络对本文工作进行试验。

![](https://i-blog.csdnimg.cn/blog_migrate/2e0ff0a5164fa6c1bc813e72b2026af2.png)

本文不是第一个考虑在CNNs中寻找传统神经模型替代方案的。例如，Jarrett等\[11\]考虑使用非线性函数，在数据集Caltech-101上，与基于局部平均池化的对比归一化结合取得了很好地效果。但是，在这个数据集上他们主要关心的就是防止过拟合，而本文用ReLUs主要是对训练集的拟合进行加速。快速学习对由大规模数据集上训练出大模型的性能有相当大的影响。

### 精读 

#### 传统方法及不足 

 *  Sigmoid 是常用的非线性的激活函数，它能够把输入的连续实值“压缩”到0和1之间。特别的，如果是非常大的负数，那么输出就是0；如果是非常大的正数，输出就是1。
 *  作者把非线性激活函数（ReLU）用在了模型里，发现训练速度显著提高，原因在于传统用的是饱和非线性激活函数，例如tanh，训练时如果进入到饱和区域，那么会因为梯度变化过小而难以训练；而ReLU是一种非饱和非线性激活函数，接受阈是0~![\infty](https://latex.csdn.net/eq?%5Cinfty)，不存在tanh的问题。

![](https://i-blog.csdnimg.cn/blog_migrate/0d5d5698f9216984931e4320c1ff36aa.png)

#### 本文改进方法 

 *  本文将具有这种非线性特征的神经元称为非线性激活函数（ReLUs: Rectified Linear Units）。Alex用ReLU代替了Sigmoid，发现使用ReLU得到的SGD的收敛速度会比 sigmoid或tanh 快很多。
 *  ReLU的有效性体现在两个方面： 1. 克服梯度消失的问题 ；2. 提高训练速度。这两个方面是相辅相成的，因为克服了梯度消失问题，所以训练才会快。

#### 本文的改进结果 

本文用ReLUs主要是对训练集的拟合进行加速。快速学习对在数据集上训练的大模型的性能有很大影响。

###  3.2Training on Multiple GPUs—用多个GPU训练 

### 翻译 

单个GTX 580 GPU只有3GB内存，这限制了可以在其上训练的网络的最大尺寸。事实证明，120万个训练样本足以训练那些因规模太大而不适合使用一个GPU训练的网络。因此，我们将网络分布在两个GPU上。目前的GPU很适合于跨GPU并行化操作，因为它们能够直接读写对方的内存，而无需通过主机内存。我们采用的并行化方案基本上将半个内核（或神经元）放在各个GPU上，另外还有一个技巧：GPU只在某些层间进行通信。这意味着，例如，第3层的内核从第2层的所有内核映射（kernel maps）中获取输入。然而，第4层中的内核又仅从位于同一GPU上的第3层中的那些内核映射获取输入。选择连接模式对于交叉验证是一个不小的问题，但这使得我们能够精确调整通信量，直到它的计算量的达到可接受的程度。  
由此产生的架构有点类似于Cire¸san等人使用的“柱状”CNN\[5\]，除了我们的每列不是独立的之外（见图2）。与一个GPU上训练的每个卷积层只有一半的内核数量的网络相比，该方案分别将我们的top-1和top-5错误率分别降低了1.7％和1.2％。双GPU网络的训练时间比单GPU网络更少。

### 精读 

#### 传统方法及不足 

 *  单个GTX580 GPU只有3GB内存，这限制了可以在其上训练的网络的最大大小。
 *  实验表明使用120万训练样本训练网络已足够，但是这个任务对一个GPU来说太大了。

#### 本文改进方法 

方法：采用两个GPU

原因：当前的GPU都能很方便地进行交叉GPU并行，因为它们可以直接相互读写内存，而不用经过主机内存。

采用技巧：

1.在每一个GPU上放二分之一的核(或者神经元)。

2.只有某些层才能进行GPU之间的通信。

#### 本文的改进结果 

（1）错误率下降：与在一个GPU上训练的网络相比，这种组合让本文的top-1和top-5错误率分别下降了1.7%和1.2%。

（2）训练时间少：本文的两个GPU网络训练时间比一个GPU的时间要略少。

###  3.3Local Response Normalization——局部归一化 

### 翻译 

ReLU具有理想的属性，它们不需要对输入进行归一化来防止它们饱和。如果至少有一些训练实例为ReLU产生了正的输入，那么这个神经元就会学习。然而，我们还是发现下面的这种归一化方法有助于泛化。设表示第个内核计算位置的ReLU非线性单元的输出，而响应归一化（Local Response Normalization）的输出值定义为：

![](https://i-blog.csdnimg.cn/blog_migrate/6dff31edcfa40aba57fb319ded055775.png)

其中，求和部分公式中的 nn表示同一个位置下与该位置相邻的内核映射的数量，而NN表示这一层所有的内核数（即通道数）。内核映射的顺序当然是任意的，并且在训练之前就已经定好了。这种响应归一化实现了一种模仿真实神经元的横向抑制，从而在使用不同内核计算的神经元输出之间产生较大的竞争。常数 kk、nn、 αα和ββ都是超参数（hyper-parameters），它们的值都由验证集决定。我们取 k=2k=2、 n=5n=5、 α=10−4α=10−4、 β=0.75β=0.75。我们在某些层的应用ReLU后再使用这种归一化方法（参见第3.5节）。  
这个方案与Jarrett等人\[11\]的局部对比归一化方案有些相似之处，但我们的被更准确地称为“亮度归一化”，因为我们没有减去均值。响应归一化将我们的top-1和top-5的错误率分别降低了1.4％和1.2％。我们还验证了这种方案在CIFAR-10数据集上的有效性：没有进行归一化的四层CNN实现了13％的测试错误率，而进行了归一化的则为11％。

### 精读 

#### 传统方法及不足 

ReLUs理想特性：ReLUS有一个理想的特性，即它们不需要输入规范化来防止它们饱和。

#### 本文改进方法 

 *  在ReLU层之前我们应用了局部归一化得到了一个更好的效果：用Aix, yx, y 表示在(X,Y)位置应用核然后应用RELU 非线性所产生的神经元的活动，即响应归一化活动Bi。其中和在同一空间位置的n个“相邻”核映射上运行，n是层中核的总数。
 *  局部响应归一化处理方法类似于生物神经元的横向抑制机制，可以理解为将局部响应最大的再放大，并抑制其他响应较小的(放大局部显著特征,作用还是提高鲁棒性)。在用ReLU非线性层之后用到局部响应归一化在特定的层。

#### 本文改进结果 

 *  （1）错误率降低：响应规范化将Top-1和Top-5错误率分别降低了1.4%和1.2%。
 *  （2）在CIFAR-10数据集上验证了该方案的有效性：一个四层CNN 在未归一化的情况下获得了13%的测试错误率，在归一化的情况下获得了11%的测试错误率。

###  3.4Overlapping Pooling—重叠池化 

### 翻译 

CNNS中的池层总结了同一核映射中相邻神经元组的输出。传统上，由相邻池单元总结的邻域不重叠（例如，参考文献5, 13, 20)。更精确地说，池层可以被认为是由池单元网格组成的，池单元网格间隔s个像素，每一个概括以池单元的位置为中心的大小为z×z的邻域。如果我们设置s=z，我们就得到了CNNS中常用的传统本地池。如果我们设置s<z，我们得到重叠合用。这就是我们在整个网络中使用的s=2和z=3。与非重叠方案S=2,Z=2相比，该方案的前1和前5误差率分别降低了0.4%和0.3%。我们通常在训练过程中观察到，使用重叠池的模型发现过度拟合的差异更大。

### 精读 

#### 传统方法及不足 

 *  传统上，邻接池化单元归纳的邻域不重叠。
 *  更精确地说，一个池化层可以被认为是由池化单元网格组成的，池化单元网格间隔s个像素，每一个概括以池化单元的位置为中心的大小为z×z的邻域。如果我们设置s=z，我们就得到了CNNS中常用的局部池化层。

#### 本文改进方法 

采用了重叠池化层：如果我们设置s<z，我们得到重叠合用。这就是我们在整个网络中使用的s=2和z=3。

#### 本文改进结果 

（1）错误率下降：与非重叠方案 S=2,Z=2相比，该方案的top-1和top-5错误率分别降低了0.4%和0.3%。

（2）过度拟合的差异更大：我们通常在训练过程中观察到，使用重叠池的模型发现过度拟合的差异更大

###  3.5Overall Architecture—整体网络架构 

### 翻译 

现在我们可以来描述本文CNN的整体结构。正如图2所示，这个网络包含八个有权值的层：前五层是卷积层，剩下的三层是全连接层。最后一个全连接层的输出传递给一个1000路的softmax层，这个softmax产生一个对1000类标签的分布。本文的网络最大化多项Logistic回归结果，也就是最大化训练集预测正确的标签的对数概率。

第二、四、五层卷积层的核只和同一个GPU上的前层的核特征图相连（见图2）。第三层卷积层和第二层所有的核特征图相连接。全连接层中的神经元和前一层中的所有神经元相连接。响应归一化层跟着第一和第二层卷积层。最大池化层，3.4节中有所描述，既跟着响应归一化层也跟着第五层卷积层。ReLU非线性变换应用于每一个卷积和全连接层的输出。

第一层卷积层使用96个大小为11x11x3的卷积核对224x224x3的输入图像以4个像素为步长（这是核特征图中相邻神经元感受域中心之间的距离）进行滤波。第二层卷积层将第一层卷积层的输出（经过响应归一化和池化）作为输入，并使用256个大小为5x5x48的核对它进行滤波。第三层、第四层和第五层的卷积层在没有任何池化或者归一化层介于其中的情况下相互连接。第三层卷积层有384个大小为3x3x256的核与第二层卷积层的输出（已归一化和池化）相连。第四层卷积层有384个大小为3x3x192的核，第五层卷积层有256个大小为 的核。每个全连接层有4096个神经元。

### 精读 

#### 网络架构 

第一层卷积层使用96个大小为11x11x3的卷积核对224x224x3的输入图像以4个像素为步长（这是核特征图中相邻神经元感受域中心之间的距离）进行滤波。第二层卷积层将第一层卷积层的输出（经过响应归一化和池化）作为输入，并使用256个大小为5x5x48的核对它进行滤波。第三层、第四层和第五层的卷积层在没有任何池化或者归一化层介于其中的情况下相互连接。第三层卷积层有384个大小为3x3x256的核与第二层卷积层的输出（已归一化和池化）相连。第四层卷积层有384个大小为3x3x192的核，第五层卷积层有256个大小为 的核。每个全连接层有4096个神经元。

![](https://i-blog.csdnimg.cn/blog_migrate/5633c27c6f8ae3a0498dd54f38a03306.png)

1.因为在两个GPU上运行，所以网络结构被一切为二，上下两部分各自训练各自的，各有各的参数核，结构都是一样的；

2.整个结构有八层，前五层为卷积层，后三层为全连接层，最后再跟一个1000路的分类激活函数softmax，相当于多个logistic回归来进行多元分类。

3.二、四、五层只与自己之前的核有关系，就是只与自己这个GPU前一层训练的输出有关系。第三层卷积层与前一层的两个GPU训练出来的都有关系，在通道维度上做了一个融合。全连接层就与前一层中所有神经元相连。

4.局部归一化（LRN）应用在了第一层和第二层的卷积层。

5.最大池化层应用在了有局部归一化的层以及第五卷积层。

6.这八个卷积层每一层都应用了ReLU函数。

7.这些层的顺序：局部归一化放在ReLU之前，然后最大池化层跟在ReLU之后。

#### 规律 

我们输入的图片从一个又高又宽又扁的一个形状，慢慢变为了一个宽和高都很小，但是很长的一个张量，这是说我们的空间信息被压缩了也就是从一开始的224变为了后面的13，也就是13中的一个像素能表示之后一大片像素。

通道数变多也就是变长了，通道数可以理解为对于一个模式的识别，例如通道数为192那么说明可以识别图中192个模式，例如猫腿、爪子这种模式。所以说整个过程就是空间信息被压缩，但是语义信息空间慢慢增加。

#### Alex运作流程： 

conv1：输入→卷积→ReLU→局部响应归一化→重叠最大池化层

conv2：卷积→ReLU→局部响应归一化→重叠最大池化层

conv3：卷积→ReLU

conv4：卷积→ReLU

conv5：卷积→ReLU→重叠最大池化层(经过这层之后还要进行flatten展平操作)

FC1：全连接→ReLU→Dropout

FC2：全连接→ReLU→Dropout

FC3(可看作softmax层)：全连接→ReLU→Softmax

## 4.Reducing Overfitting—减少过拟合 

本文的神经网络结构有6千万个参数。尽管ILSVRC的1000个类别使得每一个训练样本利用10bit的数据就可以将图像映射到标签上，但是如果没有大量的过拟合，是不足以学习这么多参数的。接下来，本文描述了两种减少过拟合的主要的方法。

###  4.1Data Augmentation-数据增强 

### 翻译 

降低图像数据过拟合的最简单常见的方法就是利用标签转换人为地增大数据集（例如\[25,4,5\]。本文采取两种不同的数据增强方式，这两种方式只需要少量的计算就可以从原图中产生转换图像，因此转换图像不需要存入磁盘。本文中利用GPU训练先前一批图像的同时，使用CPU运行Python代码生成转换图像。因此这些数据增强方法实际上是不用消耗计算资源的。

第一种数据增强的形式包括生成平移图像和水平翻转图像。做法就是从256x256的图像中提取随机的224x224大小的块（以及它们的水平翻转），然后基于这些提取的块训练网络。这个让我们的训练集增大了2048倍（(256-224)2\*2=2048），尽管产生的这些训练样本显然是高度相互依赖的。如果不使用这个方法，本文的网络会有大量的过拟合，这将会迫使我们使用更小的网络。在测试时，网络通过提取5个224x224块（四个边角块和一个中心块）以及它们的水平翻转（因此共十个块）做预测，然后网络的softmax层对这十个块做出的预测取均值。

第二种数据增强的形式包括改变训练图像的RGB通道的强度。特别的，本文对整个ImageNet训练集的RGB像素值进行了PCA。对每一幅训练图像，本文加上多倍的主成分，倍数的值为相应的特征值乘以一个均值为0标准差为0.1的高斯函数产生的随机变量。因此对每一个RGB图像像素加上如下的量

![](https://i-blog.csdnimg.cn/blog_migrate/5f922ee5b54845dba55925b2fe4b95ab.png)

这里分别是RGB像素值的3x3协方差矩阵的第个特征向量和特征值，是上述的随机变量。每一个的值对一幅特定的训练图像的所有像素是不变的，直到这幅图像再次用于训练，此时才又赋予新的值。这个方案得到了自然图像的一个重要的性质，也就是，改变光照的颜色和强度，目标的特性是不变的。这个方案将top-1错误率降低了1%。

### 精读 

减少图像数据过度拟合的最简单也是最常见的方法是使用保留标签的变换人为地放大数据集。这里用了两种方式：

#### 第一种数据增强的形式包括生成平移图像和水平翻转图像。 

具体方法：做法就是从256x256的图像中提取随机的224x224大小的块（以及它们的水平翻转），然后基于这些提取的块训练网络。这个让我们的训练集增大了2048倍（(256-224)25个224x224\*2=2048）。在测试时，网络通过提取5个224x224块（四个边角块和一个中心块）以及它们的水平翻转（因此共十个块）做预测，然后网络的softmax层对这十个块做出的预测取均值。

#### 第二种形式的数据增强包括改变训练图像中RGB通道的强度。 

具体方法：特别的，本文对整个ImageNet训练集的RGB像素值进行了PCA。对每一幅训练图像，本文加上多倍的主成分，倍数的值为相应的特征值乘以一个均值为0标准差为0.1的高斯函数产生的随机变量。

该方案近似地抓住了自然图像的一个重要性质，即物体的同一性对光照强度和颜色的变化是不变的。 该方案将TOP-1错误率降低1%以上。

###  4.2Dropout—随机失活法 

### 翻译 

结合许多不同模型的预测结果是减少测试错误率的一种非常成功的方法\[1,3\]，但对于已经花费数天时间训练的大型神经网络来说，它似乎成本太高了。然而，有一种非常有效的模型组合方法，在训练期间，只需要消耗1/2的参数。这个新发现的技术叫做“Dropout”\[10\]，它会以50%的概率将隐含层的神经元输出置为0。以这种方法被置0的神经元不参与网络的前馈和反向传播。因此，每次给网络提供了输入后，神经网络都会采用一个不同的结构，但是这些结构都共享权重。这种技术减少了神经元的复杂适应性，因为神经元无法依赖于其他特定的神经元而存在。因此，它被迫学习更强大更鲁棒的功能，使得这些神经元可以与其他神经元的许多不同的随机子集结合使用。在测试时，我们试着使用了所有的神经元，并将它们的输出乘以0.5。这与采用大量dropout的网络产生的预测结果分布的几何均值近似。  
我们在图2中的前两个全连接层上使用了dropout。没有dropout，我们的网络会出现严重的过拟合。Dropout大概会使达到收敛的迭代次数翻倍。

### 精读 

#### 引出dropout： 

结合多种不同模型的预测结果是一种可以降低测试误差的非常成功的方法，但是这对于已经要花很多天来训练的大规模神经网络来说显得太耗费时间了。但是，有一种非常有效的模型结合的方法，训练时间只需要原先的两倍。最新研究的技术，叫做“dropout”。

#### 思想： 

全连接层由于参数过于庞大，因此很容易出现过拟合，那么每次迭代的时候把一些神经元以概率p失活，这样每次迭代时都是一个新的模型，显著提高了健壮性（Robust），某种意义可以看做通过集成不同的模型来提高泛化能力

![](https://i-blog.csdnimg.cn/blog_migrate/ee7f298fa21b4803ebefd74e0450113d.png)

#### 方法： 

它将每一个隐藏神经元的输出以50%的概率设为0。以这种方式“dropped out”的神经元既不参与前向传播，也不参与反向传播。每次做完dropout，相当于从原始的网络中找到一个更瘦的网络，有了dropout之后，可以将一个大网络看作多个小网络的组合，dropout能够有效地防止过拟合。

#### 结果： 

1.因此每次有输入时，神经网络采样一个不同的结构，但是所有这些结构都共享权值。

2.这种技术减少了神经元复杂的共同适应，因为一个神经元不是依赖于特定的其他神经元存在的。

3.因此迫使要学到在连接其他神经元的多个不同随机子集的时候更鲁棒性（稳定性）的特征。

4.在测试时，本文使用所有的神经元，但对其输出都乘以了0.5，对采用多指数dropout网络生成的预测分布的几何平均数来说这是一个合理的近似。

#### 本文中的应用： 

在图2中的前两个全连接层使用dropout。如果不采用dropout，本文的网络将会出现大量的过拟合。dropout大致地使达到收敛的迭代次数增加了一倍。

## 5.Details of learning—学习的细节 

###  5.1SGD随机梯度下降法 

### 翻译 

我们使用随机梯度下降法来训练我们的模型，每个batch有128个样本，动量（momentum）为0.9，权重衰减（weight decay）为0.0005。我们发现这种较小的权重衰减对于模型的训练很重要。换句话说，权重衰减在这里不仅仅是一个正则化方法：它减少了模型的训练误差。权重ω的更新法则是：

![](https://i-blog.csdnimg.cn/blog_migrate/785f434205e14f54c9b4245d4a0eb583.png)

其中， i表示当前的迭代次数，v表示动量（momentum）， ε表示学习率， Di的平均值。

### 精读 

我们使用随机梯度下降法（SGD）训练我们的模型，批量大小为128，动量（momentum）为0.9（对传统SGD增加了动量这个观点，来解决传统SGD的一些问题，例如优化过程非常不平滑或者梯度下降很低效的时候），权值（weight decay）为0.0005（可以理解为是一个L2的正则化项，用在优化算法上而不是模型上）。

我们发现，这种少量的权值对模型的学习很重要。

###  5.2初始化参数 

### 翻译 

我们使用标准差为0.01、均值为0的高斯分布来初始化各层的权重。我们使用常数1来初始化了网络中的第二个、第四个和第五个卷积层以及全连接层中的隐含层中的所有偏置参数。这种初始化权重的方法通过向ReLU提供了正的输入，来加速前期的训练。我们使用常数0来初始化剩余层中的偏置参数。

### 精读 

（1）从标准差为0.01，均值为0的高斯分布初始化每一层的权重。

（2）将第2、4、5个卷积层和全连接起来的隐藏层的神经元偏置初始化为常数1（这样的初始化通过为ReLU提供正的输入加速了初期阶段网络的学习）。

（3）将剩余层的神经元偏置初始化为常数0。

###  5.3学习速率 

### 翻译 

我们对所有层都使用相同的学习率，在训练过程中又手动进行了调整。我们遵循的启发式方法是：以当前的学习速率训练，验证集上的错误率停止降低时，将学习速率除以10.学习率初始时设为0.01，并且在终止前减少3次。我们使用120万张图像的训练集对网络进行了大约90次迭代的训练，这在两块NVIDIA GTX 580 3GB GPU上花费了大约5到6天的时间。

### 精读 

所有层均相等，在训练中会人为调整。我们遵循的启发式方法是，当验证集的错误率不再随当前学习率提高时，将学习率除以 10。学习率初始化为0.01并在终止前减少三次。也有自动的方法，例如Resnet，训练120轮epoch，初始学习率也是设为0.01，每30轮降低十倍。本文是训练了90个epoch，每一次是120w张图片。

当然现在我们都不采用十倍十倍去降低了，我们采用更平滑的降低方式，例如利用cos函数去降低。

如下图，蓝色线为本文中的降低方式，十倍十倍去降，红色线是我们现在用的，一开始学习率设的大一些，慢慢下降，这样更高效。

![](https://i-blog.csdnimg.cn/blog_migrate/8a7492262a964cdafb546f814c17aad2.png)

## 6.Results—实验结果 

### 翻译 

们在ILSVRC-2010上取得的结果如表1所示。我们的网络的top-1和top-5测试集错误率分别为37.5％和17.0％。在ILSVRC-2010比赛期间取得的最佳成绩是47.1％和28.2％，其方法是对六种不同的稀疏编码模型所产生的预测结果求平均\[2\]。此后公布的最佳结果为45.7％、25.7％，其方法是对两种经过密集采样的特征\[24\]计算出来的Fisher向量（FV）训练的两个分类器取平均值。  
我们的网络实现了37.5％和17.0％的前1和前5个测试集错误率5。在ILSVRC-2010比赛期间取得的最佳成绩是47.1％和28.2％，其中一种方法是对六种针对不同特征进行训练的稀疏编码模型所产生的预测进行平均\[2\]，此后最佳公布结果为45.7％， 25.7％，其中一种方法是：对两个在不同取样密度的Fisher向量上训练的分类器取平均。

![](https://i-blog.csdnimg.cn/blog_migrate/ac50692384ee2f01adbc4a1de74e7d36.png)

我们还在ILSVRC-2012竞赛中使用了我们的模型，并在表2中给出了我们的结果。由于ILSVRC-2012测试集标签未公开，因此我们无法给出我们测试过的所有模型在测试集上的错误率。在本节的其余部分中，我们将验证集和测试集的错误率互换，因为根据我们的经验，它们之间的差值不超过0.1％（见表2）。本文描述的CNN的top-5错误率达到了18.2％。对五个相似CNN的预测结果计算均值，得到的错误率为16.4％。单独一个CNN，在最后一个池化层之后，额外添加第六个卷积层，对整个ImageNet Fall 2011 release(15M images, 22K categories)进行分类，然后在ILSVRC-2012上“微调”（fine-tuning）网络，得到的错误率为16.6％。对整个ImageNet Fall 2011版本的数据集下预训练的两个CNN，求他们输出的预测值与前面提到的5个不同的CNN输出的预测值的均值，得到的错误率为15.3％。比赛的第二名达到了26.2％的top-5错误率，他们的方法是：对几个在特征取样密度不同的Fisher向量上训练的分类器的预测结果取平均的方法\[7\]。

![](https://i-blog.csdnimg.cn/blog_migrate/ac6bf99e821ce0023d0509534fe6d98a.png)

最后，我们还在ImageNet Fall 2009版本的数据集上提交了错误率，总共有10,184个类别和890万张图像。在这个数据集中，我们遵循文献中的使用一半图像用于训练，一半图像用于测试的惯例。由于没有建立测试集，所以我们的拆分方法有必要与先前作者使用的拆分方法不同，但这并不会对结果产生显著的影响。我们在这个数据集上的top-1和top-5错误率分别是67.4％和40.9％，是通过前面描述的网络获得的，但是在最后的池化层上还有额外的第6个卷积层。该数据集此前公布的最佳结果是78.1％和60.9％\[19\]。

### 精读 

 *  ILSVRC-2010上，本文网络的测试集top-1和top-5的错误率分别为37.5%和17.0%。
 *  ILSVRC-2012上，本文中所描述的CNN的top-5错误率是18.2%。五个相似的CNN的平均预测结果的错误率是16.4%。在最后一个池化层上增加第六个卷积层，使用整个ImageNet Fall 2011的数据（15M图像，22000种类别）作为分类数据预训练得到的一个CNN，再经过微调，用ILSVRC-2012对该CNN进行测试得到的错误率为16.6%。对上述的五个在整个Fall 2011数据集上预训练过的CNN，得到的预测求平均得到的错误率结果为15.3%。

#### 6.1Qualitative Evaluations—定性评估 

![](https://i-blog.csdnimg.cn/blog_migrate/52b56c2ede1a430d8e0572d79396b341.png)

左侧图：八张ILSVRC-2010测试图像和我们的模型认为最可能的五个标签。正确的标签写在每张图片下面，分配给正确标签的概率也用红色条显示（如果恰好位于前5位）。

右侧图：第一列中有五幅ILSVRC-2010测试图像。剩下的列显示了在最后一个隐藏层中生成特征向量的六个训练图像，这些特征向量与测试图像的特征向量之间的欧氏距离最小（简单来说可以理解为倒数第二层提取出的特征向量最相似的几个图像，也就是说我们的神经网络在最后第二层输出的特征，在语义空间里面表现的非常好）。

## 7.Discussion—讨论 

### 翻译 

我们的研究结果表明，一个大的深层卷积神经网络能够在纯粹使用监督学习的情况下，在极具挑战性的数据集上实现破纪录的结果。值得注意的是，如果移除任何一个卷积层，网络的性能就会下降。例如，删除任何中间层的结果会导致网络性能的top-1错误率下降2%。因此网络的深度对于实现我们的结果真的很重要。  
为了简化我们的实验，我们没有使用任何无监督的预训练方法，尽管这样可能会有所帮助，特别是如果我们获得了足够的计算能力来显著地增加网络的大小而不会相应地增加已标记数据的数量。到目前为止，我们的结果已经获得了足够的进步，因为我们已经使网络更大，并且训练了更长时间。但我们仍然有很大的空间去优化网络，使之能够像人类的视觉系统一样感知。最后，我们希望对视频序列使用非常大的深度卷积神经网路，其中时间结构提供了非常有用的信息，这些信息往往在静态图像中丢失了，或者说不太明显。

### 精读 

1.本文的结果表明一个大规模深度卷积神经网络在具有高度挑战性的数据集上仅用监督学习就能够获得破纪录的好结果。

2.卷积核可以学习到频率、方向和颜色特征；

3.更强大GPU及更多的数据可进一步提高模型性能。

4.深度可决定网络能力，如果去掉一个卷积层，那么准确率会下降2%。

5.图片缩放细节，对短边先缩放；

6.ReLU不需要对输入进行标准化来防止饱和现象，而sigmoid、tanh激活函数有必要对输入做标准化；

7.没有使用无监督进行预训练。这个是有一定历史背景的，在Alexnet网络提出之前有监督学习打不过无监督学习，但是在Alexnet提出之后，引起了有监督学习的热潮，直到最新的语言模型bert的提出，才慢慢的将人们又拉回了无监督学习。

8.网络结构具有相关性，不能轻易移除某一层；

9.本文的结果已经有所提高，但我们仍然有很多需求来进行时空下人类视觉系统的研究。最终我们想要将非常大规模地深度卷积网络应用于视频序列的处理，视频序列中的时间结构提供了许多有用的信息，而这些信息在静态图中丢失了或者不是很明显。

## 论文十问 

> Q1：论文试图解决什么问题？
> 
> 本文训练了一个大型的深度卷积神经网络来进行图像分类，取得非常好的效果。

> Q2：这是否是一个新的问题？
> 
> 在当时是的。

> Q3：这篇文章要验证一个什么科学假设？
> 
>  *  本文表明一个大规模深度卷积神经网络在具有高度挑战性的数据集上仅用监督学习就能获得破纪录的好结果。
>  *  深度很重要，如果去掉一个卷积层，那么准确率会下降2%。
>  *  卷积层加连接层组成的卷积神经网络分类效果更好。
>  *  非饱和激活函数ReLU可以加快训练速度。
>  *  Dropout可以减少过拟合。

> Q4：有哪些相关研究？如何归类？谁是这一课题在领域内值得关注的研究员？
> 
> 有深度神经网络的激活函数的研究、LenNet的改进。

> Q5：论文中提到的解决方案之关键是什么？
> 
> 1.使用非线性激活函数ReLU加快了训练速度
> 
> 2.使用多个GPU并行训练
> 
> 3.在ReLU层之后应用了LRN局部归一化得到了一个更好的效果
> 
> 4.重叠池化
> 
> 5.Dropout避免过拟合
> 
> 6.五个卷积层和三个全连接层构成更深的网络架构

> Q6：论文中的实验是如何设计的？
> 
> 1.随机梯度下降法训练模型。
> 
> 2.初始化参数，从标准差为0.01，均值为0的高斯分布初始化每一层的权重，将第2、4、5个卷积层和全连接起来的隐藏层的神经元偏置初始化为常数1，将剩余层的神经元偏置初始化为常数0。
> 
> 3.每一层学习速率相同，当验证集的错误率不再随当前学习率提高时，将学习率除以10。学习率初始化为0.01并在终止前减少三次。

> Q7：用于定量评估的数据集是什么？代码有没有开源？
> 
> 数量集是ImageNet-ILSVRC2010和ImageNet-ILSVRC2012，有开源

> Q8：论文中的实验及结果有没有很好地支持需要验证的科学假设？
> 
> 有。ILSVRC-2010上，本文网络的测试集top-1和top-5的错误率分别为37.5%和17.0%。ILSVRC-2012上，本文中所描述的CNN的top-5错误率是18.2%。

> Q9：这篇论文到底有什么贡献？
> 
> 1.本文训练出了至今为止一个最大的卷积神经网络并且得到了迄今基于这些数据集最好的结果。
> 
> 2.实现了一种高度优化的二维卷积的GPU运算以及卷积神经网络训练中所有其他运算，这些都已公开。
> 
> 3.使用非线性激活函数ReLU，避免饱和问题。
> 
> 4.使用Dropout，防止过拟合问题。
> 
> 5.重叠池化。

> Q10：下一步呢？有什么工作可以继续深入？
> 
> 我们希望在视频序列上使用非常大且深度的卷积网络，其中时间结构提供了非常有用的信息，而这些信息在静态图像中缺失或不太明显。

以上就是 AlexNet（ImageNet Classification with Deep Convolutional Neural Networks）论文的全部解读啦~欢迎大家留言交流呀！

下一期：VGG


[http_papers.nips.cc_paper_4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf]: http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf
[Link 1]: #%E7%9B%AE%E5%BD%95
[Abstract-]: #Abstract-%E6%91%98%E8%A6%81
[1.Introduce]: #1.Introduce%E2%80%94%E4%BB%8B%E7%BB%8D
[2.The Dataset-]: #2.The%20Dataset-%E6%95%B0%E6%8D%AE%E9%9B%86
[3.The Architecture]: #3.The%20Architecture%E2%80%94%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84
[3.1ReLU Nonlinearity_ReLU]: #3.1ReLU%20Nonlinearity%E2%80%94%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0ReLU
[3.2Training on Multiple GPUs_GPU]: #3.2Training%20on%20Multiple%20GPUs%E2%80%94%E7%94%A8%E5%A4%9A%E4%B8%AAGPU%E8%AE%AD%E7%BB%83
[3.3Local Response Normalization]: #3.3Local%20Response%20Normalization%E2%80%94%E5%B1%80%E9%83%A8%E5%BD%92%E4%B8%80%E5%8C%96
[3.4Overlapping Pooling]: #3.4Overlapping%20Pooling%E2%80%94%E9%87%8D%E5%8F%A0%E6%B1%A0%E5%8C%96
[3.5Overall Architecture]: #3.5Overall%20Architecture%E2%80%94%E6%95%B4%E4%BD%93%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84
[4.Reducing Overfitting]: #4.Reducing%20Overfitting%E2%80%94%E5%87%8F%E5%B0%91%E8%BF%87%E6%8B%9F%E5%90%88
[4.1Data Augmentation]: #4.1Data%20Augmentation%E2%80%94%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA
[4.2Dropout]: #4.2Dropout%E2%80%94%E9%9A%8F%E6%9C%BA%E5%A4%B1%E6%B4%BB%E6%B3%95
[5.Details of learning]: #5.Details%20of%20learning%E2%80%94%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%BB%86%E8%8A%82
[5.1SGD]: #5.1SGD%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95
[5.2]: #5.2%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0
[5.3]: #5.3%E5%AD%A6%E4%B9%A0%E9%80%9F%E7%8E%87
[6.Results]: #6.Results%E2%80%94%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C
[6.1Qualitative Evaluations]: #6.1Qualitative%20Evaluations%E2%80%94%E5%AE%9A%E6%80%A7%E8%AF%84%E4%BC%B0
[7.Discussion]: #7.Discussion%E2%80%94%E8%AE%A8%E8%AE%BA
[Link 2]: #%E8%AE%BA%E6%96%87%E5%8D%81%E9%97%AE
[Link 3]: https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020