# 模板

## 【模板】manacher 

给出一个只由小写英文字符 a,b,c,…y,z 组成的字符串 *S* ,求 *S* 中最长回文串的长度 。字符串长度为 *n*。

~~~c++
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

const int MAX_LEN = 11000002 * 2;

char processed[MAX_LEN];   // 处理后的字符串（加分隔符）
int p[MAX_LEN];            // p[i] 表示以 i 为中心的最大回文半径
int cnt = 0;               // processed 数组的长度
int maxLen = 0;            // 最长回文半径

// 预处理：在字符串中插入分隔符 '|'，避免奇偶性差异
void preprocess(const string& s) {
    processed[0] = '~';        // 哨兵字符，防止越界
    processed[++cnt] = '|';    // 第一个分隔符
    for (char ch : s) {
        processed[++cnt] = ch;
        processed[++cnt] = '|';
    }
}

int main() {
    string s;
    cin >> s;                  // 读取输入字符串
    preprocess(s);             // 处理插入分隔符

    int center = 0, right = 0; // 当前回文串的中心和右边界

    for (int i = 1; i <= cnt; ++i) {
        if (i <= right)
            // i 在当前回文右边界内，使用对称位置的结果
            p[i] = min(p[2 * center - i], right - i + 1);
            
        // 尝试向两边扩展回文串
        while (processed[i - p[i]] == processed[i + p[i]]) {
            ++p[i];
        }

        // 如果扩展后的右边界超过当前 right，更新 center 和 right
        if (i + p[i] - 1 > right) {
            center = i;
            right = i + p[i] - 1;
        }

        // 更新最大长度
        maxLen = max(maxLen, p[i]);
    }

    // 最长回文子串长度为 maxLen - 1（因为处理时每个字符之间加了 '|')
    cout << (maxLen - 1) << '\n';
    return 0;
}

~~~





~~~python
import sys
sys.set_int_max_str_digits(100050)  # 允许输入高达 10005 位的数字字符串

# 输入两个超高精度整数
A = int(input().strip())
B = int(input().strip())

# 执行加、减、乘、整除、取余
print(A + B)      # 和
print(A - B)      # 差
print(A * B)      # 积
print(A // B)  # 商
print(A % B)   # 余
~~~



## 矩阵快速幂



~~~c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 105;
const int mod = 1e9 + 7;
int n, k;


struct node
{
    long long a[maxn][maxn];
    node(){
        memset(a, 0, sizeof a);
    }
    void build(){
        for(int i = 1; i <= n; ++i)a[i][i] = 1;
    }
} a;

node operator *(const node &x, const node & y){
    node z;
    for(int k = 1; k <= n; ++k)
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= n; ++j)
                z.a[i][j] = (z.a[i][j] + x.a[i][k] * y.a[k][j] % mod) % mod;
    return z;
}

void init(){
    cin >> n >> k;
    for(int i = 1; i <= n; ++i){
        for(int j = 1; j <= n; ++j){
            cin >> a.a[i][j];
        }
    }
}


void solve(){
    init();
    node ans; ans.build();
    do{
        if(k & 1) ans = ans * a;
        a = a * a;
        k >>= 1;
    }while(k);
    for(int i = 1; i <= n; ++i){
        for(int j = 1; j <= n; ++j){
            cout << ans.a[i][j] << ' ';
        }
        cout << '\n';
    }
    return;
}




signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    solve();
    return 0;
}
~~~



## tarjan

~~~c++
#include<bits/stdc++.h>
using namespace std;
int num,head[100010],dfn[100010],low[100010],cnt,vis[100010];
/*
dfn[]:时间戳，表示他在dfs(tarjan)中是第几个被搜到的
low[]:以该节点为根的子树中所有起始于该子树中的子孙节点的边所连到的点中dfn的最小值
vis[]:表示该节点是否入栈 
*/
int sum[100010],bj[100010],tot,qwq[100010];
/*
sum[]:该强联通分量中有多少个数(本题用不上，但受欢迎的牛会用到) 
bj[]:表示该节点处于哪一个强连通分量 
qwq[]:表示该强连通分量是否被其他的强连通分量所连起来 
*/
struct Edge{
	int to,next;
}edge[500010];
inline void add(int from,int to){
	num++;
	edge[num].to=to;
	edge[num].next=head[from];
	head[from]=num;
}
//以上为前向星存边 
stack<int>s;	//建栈(也可手写) 
inline void tarjan(int x){
	cnt++;
	dfn[x]=low[x]=cnt;
	s.push(x);
	vis[x]=1;
	//所有点被遍历到时的初始化 
	for(register int i=head[x];i;i=edge[i].next){
		int y=edge[i].to;
		if(dfn[y]==0){	//如果该节点未被访问过 
			tarjan(y);	//则向下遍历 
			low[x]=min(low[x],low[y]);
			//y为x的子节点,所以可以取x与y中low更小的值 
		}
		else if(vis[y]==1){
			low[x]=min(low[x],dfn[y]);
			//y在栈中因此y一定是x的祖先节点
			//low表示的是起始于该子树中的子孙节点的边所连到的点中dfn的最小值
			//所以我们和y比较的是y的dfn值，而不是low
		}
	}
	if(low[x]==dfn[x]){
//当该点的low等于自己本身说明自己就是以x为根节点的子树能到达的dfn最小的节点(在整棵树中能到达的最上方的点) 
		int z;
		tot++;	//tot表示有几个强连通分量 
		while(s.top()!=x){	//把整个强连通分量出栈 
			sum[tot]++;	
			z=s.top();	//取出栈顶 
			vis[z]=0;	//标志其不在栈中 
			bj[z]=tot;	//标志其在哪一个强连通分量 
			s.pop();	//出栈 
		}
		sum[tot]++;
		z=s.top();
		vis[z]=0;
		bj[z]=tot;
		s.pop();
	}
	return;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	int x,y;
	for(register int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(register int i=1;i<=n;i++){
		if(dfn[i]==0)
			tarjan(i);
	}
	for(register int i=1;i<=n;i++){		//遍历每一条边 
		for(register int j=head[i];j;j=edge[j].next){
			int y=edge[j].to;	
			if(bj[i]!=bj[y]){
//如果有两个强连通分量之间有边，被连的那个强连通分量就不需要再在强连通分量中扩散消息了
//只需要在那个连它的强连通分量中扩散消息，消息就会扩散到它那里来 
				qwq[bj[y]]=1;//标记此强连通分量不需要扩散消息 
			}
		}
	}
	int ans=0;
	for(register int i=1;i<=tot;i++){
		if(qwq[i]==0){
			ans++;
		}
	}
	printf("%d",ans);
	return 0;
}
~~~

